{
  "comments": [
    {
      "key": {
        "uuid": "da6255ed_cf78f12d",
        "filename": "src/main/java/org/lizardirc/beancounter/ChannelPersistor.java",
        "patchSetId": 3
      },
      "lineNbr": 57,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-09-12T16:05:41Z",
      "side": 1,
      "message": "Technically we should synchronize this as well, since forEach isn\u0027t guaranteed to behave normally when the set is modified; many implementations will fail-fast and emit a ConcurrentModificationException on a best-effort basis.",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6255ed_ef7bb527",
        "filename": "src/main/java/org/lizardirc/beancounter/ChannelPersistor.java",
        "patchSetId": 3
      },
      "lineNbr": 84,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-09-12T16:05:41Z",
      "side": 1,
      "message": "Maybe better to synchronize the PersistenceManager and make it part of the contract that PersistenceManagers are threadsafe? Since multiple objects/threads will have access to it at once, external thread safety on a pm seems difficult. Properties is already threadsafe, so for PropertiesPersistenceManager you\u0027d only need to synchronize the PropertiesWrapper\u0027s methods that touch files or the dirty map.",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6255ed_cfc6b149",
        "filename": "src/main/java/org/lizardirc/beancounter/ChannelPersistor.java",
        "patchSetId": 3
      },
      "lineNbr": 84,
      "author": {
        "id": 1
      },
      "writtenOn": "2015-09-13T02:44:15Z",
      "side": 1,
      "message": "Yeah, that seems a better approach. If I\u0027m not mistaken, if we do this, onConnect should remain synchronized (to prevent concurrent modification as you mentioned), but everything else here and in SlapListener can be made threaded again. I\u0027ll submit another patchset shortly.",
      "parentUuid": "da6255ed_ef7bb527",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6255ed_aff13d97",
        "filename": "src/main/java/org/lizardirc/beancounter/ChannelPersistor.java",
        "patchSetId": 3
      },
      "lineNbr": 84,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-09-13T04:16:37Z",
      "side": 1,
      "message": "Thinking about this, sync() can remain unsynchronized and still be threadsafe, but only because it\u0027s only called from synchronized methods so it\u0027s guaranteed to not be used concurrently. If any other methods called it, we\u0027d need to synchronize it.",
      "parentUuid": "da6255ed_cfc6b149",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6255ed_af75bd33",
        "filename": "src/main/java/org/lizardirc/beancounter/SlapListener.java",
        "patchSetId": 3
      },
      "lineNbr": 187,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-09-12T16:05:41Z",
      "side": 1,
      "message": "Ditto here. If we make pm threadsafe, this shouldn\u0027t need to be synchronized.",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6255ed_8fee79b3",
        "filename": "src/main/java/org/lizardirc/beancounter/SlapListener.java",
        "patchSetId": 3
      },
      "lineNbr": 187,
      "author": {
        "id": 5
      },
      "writtenOn": "2015-09-13T04:16:37Z",
      "side": 1,
      "message": "This one actually can\u0027t be synchronized while the unsynchronized constructor calls it.",
      "parentUuid": "da6255ed_af75bd33",
      "revId": "0e70afac7c21cdde70625b7be2d3a08d1c8365aa",
      "serverId": "cf5d0eaf-4814-484b-b55f-41cd7f22928e",
      "unresolved": false
    }
  ]
}